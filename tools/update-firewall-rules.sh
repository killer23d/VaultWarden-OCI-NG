#!/usr/bin/env bash
# tools/update-firewall-rules.sh - Manages Caddy and UFW rules for Cloudflare IPs

# Ensure strict mode and error handling
set -euo pipefail

# --- Standardized Project Root Resolution ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$PROJECT_ROOT"

# --- Standardized Library Sourcing ---
# Critical library - must exist
if [[ ! -f "lib/logging.sh" ]]; then
    echo "[ERROR] Critical library not found: lib/logging.sh" >&2
    echo "[ERROR] Ensure script is run from project directory or PROJECT_ROOT is correct" >&2
    exit 1
fi
source "lib/logging.sh"

# Additional libraries as needed (add after logging.sh)
# Source security library which contains fetch and UFW update functions
if [[ ! -f "lib/security.sh" ]]; then
    log_error "CRITICAL: Required library not found: lib/security.sh"
    exit 1
fi
source "lib/security.sh" # Provides fetch_cloudflare_ips, update_cloudflare_ufw_allowlist

# Source system library (needed for Caddy reload check/execution)
if [[ ! -f "lib/system.sh" ]]; then
    log_error "CRITICAL: Required library not found: lib/system.sh"
    # Caddy reload might fail without it
else
    source "lib/system.sh"
fi

# Set script-specific log prefix
_set_log_prefix "$(basename "$0" .sh)"

# --- Rest of script follows ---


# --- Configuration ---
# CADDY_IP_FILE is defined in security.sh via constants.sh or default
# Make sure constants.sh defines it or define it here if needed:
# readonly CADDY_IP_FILE="${CADDY_IP_FILE:-caddy/cloudflare-ips.caddy}"

# --- Functions ---

# Updates the Caddy import file with the new IP ranges
update_caddy_file() {
    local ip_file="$1" # Path to the temporary file containing fetched IPs
    log_info "Updating Caddy's trusted proxy file: $CADDY_IP_FILE"

    # Create temporary Caddy file content
    local temp_caddy_file="${CADDY_IP_FILE}.tmp.$$"
    # Ensure temp caddy file is removed on exit/error if move fails
    trap 'rm -f "$temp_caddy_file"' RETURN

    {
        echo "# Generated by $(basename "$0") on $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "# Cloudflare IP ranges for Caddy trusted proxy configuration"
        echo "@cloudflare {"
        # Read IPs/CIDRs from ip_file, trim whitespace, join with spaces
        echo -n "  remote_ip "
        paste -sd ' ' "$ip_file" # Use paste to join lines with spaces
        echo "" # Newline
        echo "}"
    } > "$temp_caddy_file" || { log_error "Failed to write temporary Caddy file $temp_caddy_file"; return 1; }

    # Basic validation of the generated file
    if ! grep -q "@cloudflare {" "$temp_caddy_file" || ! grep -q "remote_ip" "$temp_caddy_file"; then
         log_error "Generated Caddy file $temp_caddy_file seems invalid. Aborting update."
         return 1
    fi

    # Replace old file atomically
    if mv "$temp_caddy_file" "$CADDY_IP_FILE"; then
        log_success "Caddy file '$CADDY_IP_FILE' updated successfully."
        chmod 644 "$CADDY_IP_FILE" || log_warn "Failed to set permissions on $CADDY_IP_FILE"
        trap - RETURN # Clear trap after successful move
        return 0 # Success
    else
        log_error "Failed to replace $CADDY_IP_FILE with the updated version."
        # Cleanup trap will handle removing temp file
        return 1 # Failure
    fi
}


# Reloads Caddy to apply the new trusted proxy list
reload_caddy() {
    log_info "Reloading Caddy to apply updated trusted proxy list..."
    local caddy_service_name="caddy" # Assuming service name in compose is 'caddy'

    # Check if Caddy container is running using system library function if available
    local caddy_running=false
    if declare -f _compose_service_running > /dev/null; then
         if _compose_service_running "$caddy_service_name"; then
             caddy_running=true
         fi
    else
         # Fallback check using docker ps
         log_warn "_compose_service_running function not available. Using basic docker ps check."
         if docker compose ps -q "$caddy_service_name" &>/dev/null && \
            docker inspect -f '{{.State.Running}}' "$(docker compose ps -q "$caddy_service_name")" 2>/dev/null | grep -q true; then
             caddy_running=true
         fi
    fi

    if [[ "$caddy_running" == "true" ]]; then
        # Use docker compose exec to reload Caddy configuration
        # The -T flag disables pseudo-tty allocation, suitable for non-interactive exec
        log_info "Executing: docker compose exec -T $caddy_service_name caddy reload --config /etc/caddy/Caddyfile"
        if docker compose exec -T "$caddy_service_name" caddy reload --config /etc/caddy/Caddyfile; then
            log_success "Caddy configuration reloaded successfully."
            return 0 # Success
        else
            log_error "Caddy reload command failed. Check Caddy container logs."
            return 1 # Failure
        fi
    else
        log_warn "Caddy container is not running. Skipping reload."
        return 0 # Not a failure if container wasn't running
    fi
}

# --- Main Execution ---
main() {
    log_header "Cloudflare IP and Firewall Update"

    # Use a temporary file for fetched IPs
    local temp_ip_list="/tmp/cf_ips.$$.txt"
    # Ensure temporary file is cleaned up on exit or error
    trap 'rm -f "$temp_ip_list"' EXIT INT TERM

    # P2 FIX: Use centralized fetch function from existing lib/security.sh
    # This function handles retries and basic validation internally
    log_info "Fetching latest Cloudflare IPs..."
    if ! fetch_cloudflare_ips "$temp_ip_list"; then
        # fetch_cloudflare_ips logs the error details
        log_error "Failed to fetch Cloudflare IPs. Aborting update."
        exit 1
    fi
    log_success "Successfully fetched Cloudflare IPs to temporary file."

    # Update the Caddy import file using the fetched IPs
    if ! update_caddy_file "$temp_ip_list"; then
        log_error "Failed to update Caddy IP file '$CADDY_IP_FILE'. Aborting."
        exit 1
    fi

    # Reload Caddy configuration *before* changing firewall rules
    # This ensures Caddy trusts the new IPs before the firewall might block old ones
    if ! reload_caddy; then
        log_error "Caddy reload failed. Aborting UFW update to prevent potential issues."
        log_warn "Manual intervention may be required to reload Caddy configuration."
        exit 1
    fi

    # Update UFW rules using the function from security.sh
    # This function handles sudo automatically if needed
    if ! update_cloudflare_ufw_allowlist; then
         log_error "Failed to update UFW firewall rules."
         # Don't necessarily exit? Caddy file updated and reloaded, which is primary goal.
         # Log error but maybe allow script to finish successfully?
         # For now, let's exit with error if UFW fails.
         exit 1
    fi

    # Cleanup handled by trap

    log_header "Update Complete"
    log_success "Cloudflare IPs updated for Caddy and UFW firewall."
    exit 0
}

# --- Script Entry Point ---
# Requires root privileges (for UFW update)
if [[ $EUID -ne 0 ]] && ! command -v sudo >/dev/null; then
    log_error "This script requires root privileges (or sudo) to update UFW rules."
    exit 1
fi

# Execute main function
main
